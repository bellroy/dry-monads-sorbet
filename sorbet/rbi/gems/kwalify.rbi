# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/kwalify/all/kwalify.rbi
#
# kwalify-0.7.2

module Kwalify
  def self.meta_validator; end
  def self.msg(key); end
  def self.word(key); end
  extend Kwalify::ErrorHelper
  extend Kwalify::Types
end
module Kwalify::Boolean
end
class TrueClass
  include Kwalify::Boolean
  include Kwalify::Scalar
end
class FalseClass
  include Kwalify::Boolean
  include Kwalify::Scalar
end
module Kwalify::Text
  include Kwalify::Scalar
end
class String
  include Kwalify::Scalar
  include Kwalify::Text
end
class Numeric
  include Kwalify::Scalar
  include Kwalify::Text
end
module Kwalify::Scalar
end
class Date
  include Kwalify::Scalar
end
class Time
  include Kwalify::Scalar
end
class NilClass
  include Kwalify::Scalar
end
module Kwalify::Types
  def collection?(val); end
  def collection_type?(type); end
  def scalar?(val); end
  def scalar_type?(type); end
  def self.collection?(val); end
  def self.collection_type?(type); end
  def self.get_type_class(type); end
  def self.scalar?(val); end
  def self.scalar_type?(type); end
  def self.type_class(type); end
  def self.type_table; end
end
class Kwalify::KwalifyError < StandardError
end
class Kwalify::AssertionError < Kwalify::KwalifyError
  def initialize(msg); end
end
class Kwalify::BaseError < Kwalify::KwalifyError
  def <=>(ex); end
  def _to_s; end
  def column; end
  def column=(arg0); end
  def error_symbol; end
  def error_symbol=(arg0); end
  def filename; end
  def filename=(arg0); end
  def initialize(message = nil, path = nil, value = nil, rule = nil, error_symbol = nil); end
  def linenum; end
  def linenum=(arg0); end
  def message; end
  def path; end
  def path=(arg0); end
  def rule; end
  def rule=(arg0); end
  def to_s; end
  def value; end
  def value=(arg0); end
end
class Kwalify::SchemaError < Kwalify::BaseError
  def initialize(message = nil, path = nil, rule = nil, value = nil, error_symbol = nil); end
end
class Kwalify::ValidationError < Kwalify::BaseError
  def initialize(message = nil, path = nil, rule = nil, value = nil, error_symbol = nil); end
end
class Kwalify::SyntaxError < Kwalify::BaseError
  def initialize(msg, linenum = nil, error_symbol = nil); end
  def message; end
end
class Kwalify::YamlSyntaxError < Kwalify::SyntaxError
end
module Kwalify::ErrorHelper
  def _build_message(message_key, val, args); end
  def assert_error(message = nil); end
  def schema_error(error_symbol, rule, path, val, args = nil); end
  def self._build_message(message_key, val, args); end
  def self.validate_error(error_symbol, rule, path, val, args = nil); end
  def validate_error(error_symbol, rule, path, val, args = nil); end
end
class Kwalify::Rule
  def _check_confliction(hash, rule, path); end
  def _init(hash, path = nil, rule_table = nil); end
  def _init_assert_value(val, rule, path); end
  def _init_class_value(val, rule, path); end
  def _init_default_value(val, rule, path); end
  def _init_desc_value(val, rule, path); end
  def _init_enum_value(val, rule, path); end
  def _init_ident_value(val, rule, path); end
  def _init_length_value(val, rule, path); end
  def _init_mapping_value(val, rule, path, rule_table); end
  def _init_name_value(val, rule, path); end
  def _init_pattern_value(val, rule, path); end
  def _init_range_value(val, rule, path); end
  def _init_required_value(val, rule, path); end
  def _init_sequence_value(val, rule, path, rule_table); end
  def _init_type_value(val, rule, path); end
  def _init_unique_value(val, rule, path); end
  def _inspect(str = nil, level = nil, done = nil); end
  def _uniqueness_check_table; end
  def assert; end
  def assert_proc; end
  def classname; end
  def classobj; end
  def default; end
  def desc; end
  def enum; end
  def get_init_method(sym); end
  def ident; end
  def initialize(hash = nil, parent = nil); end
  def length; end
  def mapping; end
  def name; end
  def parent; end
  def parent=(arg0); end
  def pattern; end
  def range; end
  def regexp; end
  def required; end
  def sequence; end
  def type; end
  def type_class; end
  def unique; end
  include Kwalify::ErrorHelper
end
class Kwalify::Validator
  def _inspect; end
  def _validate(value, rule, path, errors, done, uniq_table, recursive = nil); end
  def _validate_assert(value, rule, path, errors); end
  def _validate_enum(value, rule, path, errors); end
  def _validate_length(value, rule, path, errors); end
  def _validate_mapping(hash, map_rule, path, errors, done, uniq_table, recursive = nil); end
  def _validate_mapping_required_keys(hash, map_rule, path, errors); end
  def _validate_pattern(value, rule, path, errors); end
  def _validate_range(value, rule, path, errors); end
  def _validate_scalar(value, rule, path, errors, done, uniq_table); end
  def _validate_sequence(list, seq_rule, path, errors, done, uniq_table, recursive = nil); end
  def _validate_unique(value, rule, path, errors, uniq_table); end
  def initialize(hash_or_rule, &block); end
  def rule; end
  def validate(value); end
  def validate_hook(value, rule, path, errors); end
  include Kwalify::ErrorHelper
end
module Kwalify::Util
  def _traverse_rule(rule, _done = nil, &block); end
  def _traverse_schema(hash, _done = nil, &block); end
  def create_hashtable(hashlist, primarykey, flag_duplicate_check = nil); end
  def get_class(classname); end
  def get_value(obj, path); end
  def self._traverse_rule(rule, _done = nil, &block); end
  def self._traverse_schema(hash, _done = nil, &block); end
  def self.create_hashtable(hashlist, primarykey, flag_duplicate_check = nil); end
  def self.get_class(classname); end
  def self.get_value(obj, path); end
  def self.traverse_rule(validator, &block); end
  def self.traverse_schema(schema, &block); end
  def self.untabify(str, width = nil); end
  def traverse_rule(validator, &block); end
  def traverse_schema(schema, &block); end
  def untabify(str, width = nil); end
end
class Kwalify::BaseParser
  def _getch; end
  def _set_column_and_linenum(s); end
  def _syntax_error(message, path = nil, linenum = nil, column = nil); end
  def column; end
  def eos?; end
  def filename; end
  def group(n); end
  def linenum; end
  def match?(regexp); end
  def peep(n = nil); end
  def reset(input, filename = nil, untabify = nil); end
  def scan(regexp); end
  def scan_string; end
end
module Kwalify::Yaml
  def self.load(yaml_str, opts = nil); end
  def self.load_file(filename, opts = nil); end
end
class Kwalify::Yaml::Parser < Kwalify::BaseParser
  def _error(klass, message, path, linenum, column); end
  def _getclass(classname); end
  def _parse_map_value(map, map_rule, path, level, key, is_merged, uniq_table, _linenum, _column, _linenum2, _column2); end
  def _set_error_info(linenum = nil, column = nil, &block); end
  def _validate_map_value(map, map_rule, rule, path, uniq_table, key, val, _linenum, _column); end
  def add_to_seq(rule, seq, val, linenum, column); end
  def create_mapping(rule, linenum, column); end
  def create_scalar(rule, value, linenum, column); end
  def create_sequence(rule, linenum, column); end
  def data_binding; end
  def data_binding=(arg0); end
  def document_start?; end
  def errors; end
  def has_next?; end
  def initialize(validator = nil, properties = nil); end
  def location(path); end
  def mapping_class; end
  def mapping_class=(arg0); end
  def parse(input = nil, opts = nil); end
  def parse_alias(rule, path, uniq_table, container); end
  def parse_anchor(rule, path, uniq_table, container); end
  def parse_block_map(map, map_rule, path, uniq_table); end
  def parse_block_scalar(rule, path, uniq_table); end
  def parse_block_seq(seq, seq_rule, path, uniq_table); end
  def parse_block_text(column, rule, path, uniq_table); end
  def parse_block_value(level, rule, path, uniq_table, container); end
  def parse_documents(input, opts = nil, &block); end
  def parse_file(filename, opts = nil); end
  def parse_flow_map(map, map_rule, path, uniq_table); end
  def parse_flow_scalar(rule, path, uniq_table); end
  def parse_flow_seq(seq, seq_rule, path, uniq_table); end
  def parse_flow_value(rule, path, uniq_table, container); end
  def parse_next; end
  def parse_stream(input, opts = nil, &block); end
  def preceding_alias; end
  def preceding_alias=(arg0); end
  def put_to_map(rule, map, key, val, linenum, column); end
  def reset_parser; end
  def reset_scanner(input, filename = nil, untabify = nil); end
  def resolve_preceding_aliases(val); end
  def sequence_class; end
  def sequence_class=(arg0); end
  def set_errors_linenum(errors); end
  def skip_spaces_and_comments; end
  def stream_end?; end
  def to_mapkey(str); end
  def to_scalar(str); end
  def validator; end
  def validator=(arg0); end
end
class Kwalify::MetaValidator < Kwalify::Validator
  def initialize(schema, &block); end
  def self.instance; end
  def validate_hook(value, rule, path, errors); end
end
class Kwalify::PlainYamlParser
  def _getchar; end
  def _getline; end
  def add_to_map(map, key, value, linenum); end
  def add_to_seq(seq, value, linenum); end
  def assert(bool_expr); end
  def create_mapping(linenum = nil); end
  def create_scalar(value, linenum = nil); end
  def create_sequence(linenum = nil); end
  def current_char; end
  def current_line; end
  def current_linenum; end
  def getchar; end
  def getchar_or_nl; end
  def getlabel; end
  def getline; end
  def has_next?; end
  def initialize(yaml_str); end
  def merge_map(map, map2, linenum); end
  def parse; end
  def parse_alias(column, value); end
  def parse_all; end
  def parse_anchor(column, value); end
  def parse_block_text(column, value); end
  def parse_child(column); end
  def parse_flow(depth); end
  def parse_flow_map(depth); end
  def parse_flow_map_item(depth); end
  def parse_flow_scalar(depth); end
  def parse_flow_seq(depth); end
  def parse_flow_seq_item(depth); end
  def parse_flowstyle(column, value); end
  def parse_mapping(column, value); end
  def parse_scalar(indent, value); end
  def parse_sequence(column, value); end
  def parse_tag(column, value); end
  def parse_value(column, value, value_start_column); end
  def register_alias(label); end
  def register_anchor(label, data); end
  def reset_sbuf(str); end
  def resolve_aliases(data); end
  def set_default(map, value, linenum); end
  def set_map_with(map, key, value, linenum); end
  def set_seq_at(seq, i, value, linenum); end
  def syntax_error(error_symbol, arg = nil, linenum = nil); end
  def to_scalar(str); end
  def white?(ch); end
end
class Kwalify::PlainYamlParser::Alias
  def initialize(label, linenum); end
  def label; end
  def linenum; end
end
class Kwalify::YamlParser < Kwalify::PlainYamlParser
  def add_to_map(map, key, value, linenum); end
  def add_to_seq(seq, value, linenum); end
  def create_mapping(linenum = nil); end
  def create_scalar(value, linenum = nil); end
  def create_sequence(linenum = nil); end
  def initialize(*args); end
  def merge_map(map, collection, linenum); end
  def parse; end
  def path_linenum(path); end
  def set_default(map, value, linenum); end
  def set_error_linenums(errors); end
  def set_errors_linenum(errors); end
  def set_map_with(map, key, value, linenum); end
  def set_seq_at(seq, i, value, linenum); end
end
class Kwalify::Parser < Kwalify::YamlParser
  def initialize(yaml_str); end
end
module Kwalify::Json
end
